<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
        <title>Jedi - Decluttering Java - Annotations</title>
        <link rel="stylesheet" href="css/style.css" type="text/css"/>
        <meta http-equiv="content-type" content="text/html; charset=utf-8"/>
        <meta name="author" content="Lance Walton" lang="en-uk"/>
    </head>
    <body>
        <div class="main">
            <div class="pageTitle">Annotations in Jedi</div>
            <div class="contents">
                <ul>
                    <li> <a href="#introduction" title="Introduction">Introduction</a>
                    </li>
                    <li> <a href="#factoryClasses" title="Factory Classes">Factory Classes</a>
                    </li>
                    <li> <a href="#jediAnnotations" title="@Jedi Annotations">@Jedi Annotations</a>
                    </li>
                    <li> <a href="#sithAnnotations" title="@Sith Annotations">@Sith Annotations</a>
                    </li>
                    <li><a href="#cuts" title="Cuts">Cuts</a>
                    </li>
                    <li><a href="#closureEquality" title="Closure Equality">Closure Equality</a>
                    </li>
                    <li><a href="#miscellaneous" title="Miscellaneous">Miscellaneous</a>
                    </li>
                    <li><a href="index.html" title="Back to Jedi">Back to Jedi</a>
                    </li>
                </ul>
            </div>
            
            <div class="sectionHeading"><a name="introduction">Introduction</a>
            </div>
            <p>Jedi tries tries to take the hard work out of using its <a href="javadoc/index.html" title="Jedi JavaDoc">APIs</a>. In Java, one of the burdens of
                the more functional style promoted by Jedi is the syntactic clutter of anonymous classes for closures. Jedi helps with this by providing
                annotations which generate factory classes. These provide methods for creating closures which can be used with the Jedi API to invoke your code
                appropriately.</p>
            <p>There are two types of annotations: those starting with <code>@Jedi</code> and those starting with <code>@Sith</code>. The two sets have
                correspondences but the thing to keep in mind is that <code>@Jedi</code> annotations allow a type to declare services available to others,
                whereas <code>@Sith</code> annotations declare that another type is required to be manipulated into providing services. <code>@Jedi</code>
                annotations should be used when you control the source code of the type for which you want to produce closures. <code>@Sith</code> annotations
                should be used (sparingly) when you do not control the relevant source code. To obtain the classes described below for any particular type, either
                <code>@Jedi</code> or <code>@Sith</code> annotations should be used. The annotations applying to a particular type must all be
                <code>@Jedi</code> or all <code>@Sith</code>. Mixing the two will cause unpredicatable results, <i>e.g.</i> galactic war.</p>
            
            <div class="sectionHeading"><a name="factoryClasses">Factory Classes</a>
            </div>
            <p>Three factory classes will be created for each annotated class. The factory classes are meant to support different coding and testing styles.
                Suppose the class containing the annotations is called <code>Stormtrooper</code>. The following three classes will be created:</p>
            <ul>
                <li><code>IStormtrooperClosureFactory</code> - this interface has declarations for all of the appropriate factory methods. Each factory
                    method will take parameters appropriate to the annotated method (or no parameters if the annotation is placed on a field)
                    that generated it and will return an instance of an appropriate closure (see below). This is ideal for dependency injection
                    and unit testing with mocks.</li>
                <li><code>StormtrooperClosureFactory</code> - this class implements <code>IStormtrooperClosureFactory</code>. Each factory method
                    will create and return an instance of the appropriate closure (see below). This can be used as a default implementation of
                    <code>IStormTrooperClosureFactory</code> in your production code. Exceptions thrown by the annotated method will be transformed into
                    <code>RuntimeException</code>s.</li>
                <li><code>StormtrooperStaticClosureFactory</code> - this class has static factory methods and is ideally used with static imports (for
                    brevity) in the client code. The factory methods have the same signature as those declared in <code>IStormtrooperClosureFactory</code>.
                    Internally, each method delegates to an instance of <code>IStormtrooperClosureFactory</code>. This instance can be set using the
                    <code>setDelegate(IStormtrooperClosureFactory)</code> method if you want to replace the default (during testing maybe). The default
                    delegate can be restored with the <code>useDefaultDelegate()</code> method.</li>
            </ul>
            <p>These factories will be created in the same package as the type to which they apply. For <code>@Jedi</code> annotations this will be the type in which
                the annotation is placed. In the case of <code>@Sith</code> annotations, this will be the type which is specified in the anotation (compile time
                annotations are not allowed to generate code into packages whose first element is 'java', so if you use an <code>@Sith</code> annotation referencing
                a class in a <code>java.*</code> package, <code>java</code> will be replaced with <code>sith</code> for the package of the generated code). Which
                directory they appear in depends on the settings you choose during <a href="index.html#compiling" title="Compiling">compilation</a>.</p>
            
            <div class="sectionHeading"><a name="jediAnnotations">@Jedi Annotations</a>
            </div>
            <p>This is what the <code>@Jedi</code> annotation declarations look like. <code>@JediFilter</code> and <code>@JediFunctor</code> look the same
                with the obvious change in name (but <code>@JediCommand</code> cannot annotate a field).</p>
            <ul class="codeBlock">
                <li>
                    <span class="annotation">@Target</span>({ElementType.METHOD, ElementType.FIELD})</li>
                <li>
                    <span class="annotation">@Retention</span>(RetentionPolicy.SOURCE)</li>
                <li>
                    <span class="keyword">public @interface</span> JediCommand {</li>
                <li>&nbsp;&nbsp;String name()
                    <span class="keyword">default</span>
                    <span class="string">""</span>;</li>
                <li>&nbsp;&nbsp;JediCut[] cut()
                    <span class="keyword">default</span> {};</li>
                <li>}</li>
            </ul>
            <p>The table below contains a set of examples. The first column shows a fragment of source code from a <code>Stormtrooper</code> class with one or more
                annotations, and the second shows the generated factory method signatures of the <code>IStormtrooperClosureFactory</code>.
                <code>@JediFilter</code> and <code>@JediFunctor</code> will have the same kind os effects, except that methods thus annotated must have a
                non-<code>void</code> return type, and <code>@JediFilter</code> behaves differently if the method it is annotating returns a
                <code>boolean</code>&nbsp;/&nbsp;<code>Boolean</code> as opposed to any other type (see the examples at the bottom of the table).</p>
            <table>
                <tr>
                    <td colspan="2">
                        <span class="subSectionHeading">The simplest annotation:</span>
                    </td>
                </tr>
                <tr>
                    <td class="codeBlock">
                        <span class="annotation">@JediCommand</span>
                        <br/>
                        <span class="keyword">public void</span> attack() {&hellip; }</td>
                    <td class="codeBlock">
                        <span class="comment">// The returned Command will invoke attack()
                            <br/>// on any Stormtrooper with which it is executed</span>
                        <br/><a href="javadoc/jedi/functional/Command.html" title="JavaDoc for jedi.functional.Command">Command</a>
                        &lt;Stormtrooper&gt; attackCommand();</td>
                </tr>
                <tr>
                    <td colspan="2"/>
                </tr>
                <tr>
                    <td colspan="2">
                        <span class="subSectionHeading">Rename the factory method:</span>
                    </td>
                </tr>
                <tr>
                    <td class="codeBlock">
                        <span class="annotation">@JediCommand</span>(name =
                        <span class="string">"pummelMercilessly"</span>)
                        <br/>
                        <span class="keyword">public void</span> attack() {&hellip; }</td>
                    <td class="codeBlock">
                        <span class="comment">// The returned Command will invoke attack()
                            <br/>// on any Stormtrooper with which it is executed</span>
                        <br/><a href="javadoc/jedi/functional/Command.html" title="JavaDoc for jedi.functional.Command">Command</a>
                        &lt;Stormtrooper&gt; pummelMercilesslyCommand();</td>
                </tr>
                <tr>
                    <td colspan="2"/>
                </tr>
                <tr>
                    <td colspan="2">
                        <span class="subSectionHeading">Parameters:</span>
                    </td>
                </tr>
                <tr>
                    <td class="codeBlock">
                        <span class="annotation">@JediCommand</span>
                        <br/>
                        <span class="keyword">public void</span> attack(Target
                        <span class="variable">target</span>) {&hellip; }</td>
                    <td class="codeBlock">
                        <span class="comment">// The returned Command will invoke attack(target)
                            <br/>// on any Stormtrooper with which it is executed</span>
                        <br/><a href="javadoc/jedi/functional/Command.html" title="JavaDoc for jedi.functional.Command">Command</a>
                        &lt;Stormtrooper&gt; attackCommand(Target
                        <span class="variable">target</span>);
                        <br/>
                        <br/>
                        <span class="comment">// When executed with an instance of Target, the returned
                            <br/>// Command will invoke attack(target) on $receiver,
                            <br/>// which must not be <code>null</code></span>
                        <br/><a href="javadoc/jedi/functional/Command.html" title="JavaDoc for jedi.functional.Command">Command</a>
                        &lt;Target&gt; attackProxyCommand(Stormtrooper
                        <span class="variable">$receiver</span>);</td>
                </tr>
                <tr>
                    <td colspan="2"/>
                </tr>
                <tr>
                    <td colspan="2">
                        <span class="subSectionHeading">More Parameters:</span>
                    </td>
                </tr>
                <tr>
                    <td class="codeBlock">
                        <span class="annotation">@JediCommand</span>
                        <br/>
                        <span class="keyword">public void</span> attack(Target
                        <span class="variable">target</span>, Weapon
                        <span class="variable">weapon</span>) {&hellip; }</td>
                    <td class="codeBlock">
                        <span class="comment">// The returned Command will invoke attack(target, weapon)
                            <br/>// on any Stormtrooper with which it is executed</span>
                        <br/><a href="javadoc/jedi/functional/Command.html" title="JavaDoc for jedi.functional.Command">Command</a>
                        &lt;Stormtrooper&gt; attackCommand(Target
                        <span class="variable">target</span>, Weapon
                        <span class="variable">weapon</span>);
                        <br/>
                        <br/>
                        <span class="comment">// When executed with instances of Target and Weapon, the returned
                            <br/>// Command2 will invoke attack(target, weapon) on $receiver, which
                            <br/>// must not be <code>null</code></span>
                        <br/><a href="javadoc/jedi/functional/Command2.html" title="JavaDoc for jedi.functional.Command2"> Command2</a>
                        &lt;Target, Weapon&gt; attackProxyCommand2(Stormtrooper
                        <span class="variable">$receiver</span>);</td>
                </tr>
                <tr>
                    <td colspan="2"/>
                </tr>
                <tr>
                    <td colspan="2">
                        <span class="subSectionHeading">Cuts</span> (see <a href="#cuts" title="Cuts">below</a>):</td>
                </tr>
                <tr>
                    <td class="codeBlock">
                        <span class="annotation">@JediCommand</span>(cut = {
                        <span class="annotation">@JediCut</span>(parameter = {
                        <span class="string">"weapon"</span>})})
                        <br/>
                        <span class="keyword">public void</span> attack(Target
                        <span class="variable">target</span>, Weapon
                        <span class="variable">weapon</span>) {&hellip; }</td>
                    <td class="codeBlock">
                        <span class="comment">// The returned Command2 will invoke attack(target, weapon)
                            <br/>// when it is executed with a Stormtrooper and a Weapon</span>
                        <br/><a href="javadoc/jedi/functional/Command2.html" title="JavaDoc for jedi.functional.Command2"> Command2</a>
                        &lt;Stormtrooper, Target&gt; attackCommand2(Target
                        <span class="variable">target</span>);
                        <br/>
                        <br/>
                        <span class="comment">// When executed with an instance of Target, the returned
                            <br/>// Command will invoke attack(target, weapon) on $receiver, which
                            <br/>// must not be <code>null</code></span>
                        <br/><a href="javadoc/jedi/functional/Command.html" title="JavaDoc for jedi.functional.Command">Command</a>
                        &lt;Target&gt; attackProxyCommand(Stormtrooper
                        <span class="variable">$receiver</span>, Weapon
                        <span class="variable">Weapon</span>);</td>
                </tr>
                <tr>
                    <td colspan="2">
                        <span class="subSectionHeading"><code>@JediFilter</code> on a method with a boolean return type:</span>
                    </td>
                </tr>
                <tr>
                    <td class="codeBlock">
                        <span class="annotation">@JediFilter</span>
                        <br/>
                        <span class="keyword">public boolean</span> isAttacking() {&hellip; }</td>
                    <td class="codeBlock">
                        <span class="comment">// The returned Filter will invoke isAttacking()
                            <br/>// when it is executed with a Stormtrooper and
                            <br/>// pass back the return value</span>
                        <br/><a href="javadoc/jedi/functional/Filter.html" title="JavaDoc for jedi.functional.Filter">Filter</a>
                        &lt;Stormtrooper&gt; isAttackingFilter();</td>
                </tr>
                <tr>
                    <td colspan="2">
                        <span class="subSectionHeading"><code>@JediFilter</code> on a method with a non-boolean return type:</span>
                    </td>
                </tr>
                <tr>
                    <td class="codeBlock">
                        <span class="annotation">@JediFilter</span>
                        <br/>
                        <span class="keyword">public</span> String getDesignation() {&hellip; }</td>
                    <td class="codeBlock">
                        <span class="comment">// The returned Filter will invoke getDesignation() when it
                            <br/>// is executed with a Stormtrooper and compare the returned
                            <br/>// designation with the given <code>$testValue</code>, which must not
                            <br/>// be <code>null</code></span>
                        <br/><a href="javadoc/jedi/functional/Filter.html" title="JavaDoc for jedi.functional.Filter">Filter</a>
                        &lt;Stormtrooper&gt; getDesignationEqualsFilter(String
                        <span class="variable">$testValue</span>);
                        <br/>
                        <br/>
                        <span class="comment">// The returned Filter will invoke getDesignation() when it
                            <br/>// is executed with a Stormtrooper and determine if the returned
                            <br/>// designation is in the given <code>$testValue</code> collection, which must
                            <br/>// not be <code>null</code></span>
                        <br/><a href="javadoc/jedi/functional/Filter.html" title="JavaDoc for jedi.functional.Filter">Filter</a>
                        &lt;Stormtrooper&gt; getDesignationMembershipFilter(Collection
                        <span class="variable">$testValue</span>);</td>
                </tr>
            </table>
            
            <div class="sectionHeading"><a name="cuts">Cuts</a>
            </div>
            <ul class="codeBlock">
                <li>
                    <span class="keyword">public @interface</span> JediCut {</li>
                <li>&nbsp;&nbsp;String name()
                    <span class="keyword">default</span>
                    <span class="string">""</span>;</li>
                <li>&nbsp;&nbsp;String[] parameters()
                    <span class="keyword">default</span> {};</li>
                <li>}</li>
            </ul>
            
            <p>'Cuts' are a way of moving parameters between a closure's factory method parameter list and its <code>execute</code> method parameter list. They
            	can only be used when the enclosing annotation annotates a method (<i>i.e.</i> a cut makes no sense for a field annotation). The
                parameters move in different directions depending on whether the factory method is a <code>Proxy</code> type or not. Using the examples in the
                table above is the easiest way of describing their action. Look at the rows entitled 'More Parameters' and 'Cuts'. Both rows shows an annotated
                method with the same two parameters. When the factory classes are generated, two factory methods are created for this method in each case.</p>
            <p>The first, <code>attackCommand(Target,&nbsp;Weapon)</code> takes the annotated method's parameters as factory method parameters. Every
                <code>Stormtrooper</code> which is passed to the <code>execute</code> method of the command will have their
                <code>attack(Target,&nbsp;Weapon)</code> method called with the <i>same</i> <code>Target</code> and <code>Weapon</code> . <i>i.e.</i>
                this is un underfunded army so they have to share weapons.</p>
            <p>By contrast, in the 'Cuts' version, the <code>weapon</code> is cut. This has the effect of 'cutting' the weapon out of the parameter list that it
                would have been in (the factory method's list) and placing it in the only other available place which is the closure's <code>execute</code> method
                list. This means that the command now has two parameters, the Stormtrooper and the Weapon. <i>i.e.</i> the target has been chosen, but choice of
                <code>Stormtrooper</code>s and their corresponding <code>Weapon</code>s has been deferred.</p>
            <p>In the <code>Proxy</code> versions of the factory methods, the situation is reversed. In the uncut version, the only thing determined by the
                factory method is the <code>Stormtrooper</code> which is going to be attacking. The command's <code>execute</code> method takes the
                <code>Target</code> and <code>Weapon</code>.</p>
            <p>In the cut version, the weapon is hoisted out of the <code>execute</code> method's parameter list and placed into the factory method's parameter
                list. This means that the decisions has been made about which stormtrooper and which weapon to use, only the target remains to be chosen when the
                command is <code>execute</code>d.</p>
            <div class="subSectionHeading">Renaming Cuts</div>
            <p>As indicated by the <code>@JediCommand</code> declaration above, it is possible to specify a list of cuts for a method. Each of these will cause at
                least one factory method to be created. It is possible that this will cause factory method signature clashes, which the compiler will moan about. If
                this occurs, you can rename a cut, in a way similar to that shown in the table above; all that is required is to specify a <code>name</code> inside the
                <code>@JediCut</code> parameter list. This will override any <code>name</code> specified in the enclosing <code>@Jedi</code>
                annotation.</p>
            
            <div class="sectionHeading"><a name="sithAnnotations">@Sith Annotations</a>
            </div>
            <p><code>@Sith</code> annotations all start with the word 'Sith'. They can annotate methods, types or fields and require two parameters. They can be
                used when you do not control the source code of the classes for which you want to produce the factory types. Each <code>@Jedi</code> annotation has a
                corresponding <code>@Sith</code> annotation (<i>i.e.</i> <code>@SithCommand</code>, <code>@SithFilter</code>,
                <code>@SithFunctor</code>). Cuts and renames are not available for <code>@Sith</code> annotations.</p>
            <p>The parameters required by all three <code>@Sith</code> annotations are the same:</p>
            <ul>
                <li><code>type</code> - the Java type which you want to manipulate.</li>
                <li><code>methods</code> - a list of method signatures for which you want to produce the closure type. Each signature is specified using another
                    annotation, <code>@SithMethod</code>.</li>
            </ul>
            <p>For example, the following annotation on any type, method or field in your code base will produce closure factories for
                <code>java.util.Set</code>.</p>
            <ul class="codeBlock">
                <li>@SithFilter(</li>
                <li>&nbsp;&nbsp;
                    <span class="variable">type</span> = Set.class,</li>
                <li>&nbsp;&nbsp;
                    <span class="variable">methods</span> = {</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;@SithMethod(
                    <span class="variable">name</span> =
                    <span class="string">"contains"</span>,
                    <span class="variable">parameterTypes</span> = {Object.class})</li>
                <li>&nbsp;&nbsp;}</li>
                <li>)</li>
            </ul>
            
            <p><code>@Sith</code> annotations for a particular <code>type</code> are aggregated over the entire codebase and duplicates are eliminated.
                <i>i.e.</i> you can place <code>@Sith</code> annotations for the same <code>type</code> in many different source files and they will all be
                combined into one set of closure factories in the same package as the given <code>type</code>.</p>
            
            <div class="sectionHeading"><a name="closureEquality">Closure Equality</a>
            </div>
            <p>It can sometimes be useful to compare closures created by the generated factories for equality (unit testing, for example). This works perfectly
                well; each closure produced by a particular factory method is equal to every other closure produced by the same factory method, providing that the
                factory methods parameters are also equal according to the <code>equals(Object)</code> method (or <code>==</code> for primitives).</p>
            <p><code>hashCode()</code> will also yield consistent results, the calculation depending only on the <code>hashCode</code>s of the
                parameters.</p>
            <div class="sectionHeading"><a name="miscellaneous">Miscellaneous</a>
            </div>
            <ul>
                <li>Closures created by generated factories are <a href="http://java.sun.com/j2se/1.4.2/docs/api/java/io/Serializable.html">
                    Serializable</a>.</li>
                <li>Checked exceptions thrown by annotated methods are transformed into <a href="javadoc/jedi/JediException.html"
                        title="JavaDoc for jedi.JediException">JediExceptions</a></li>
            </ul>
        </div>
    </body>
</html>